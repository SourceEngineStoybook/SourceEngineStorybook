//==================================================================================================
//
// Fake Atmosphere Shader Created by White_Red_Dragons ( ShiroDkxtro2#8750 )
//
//==================================================================================================

// STATIC: "FLASHLIGHT"                 "0..1"
// STATIC: "FLASHLIGHTDEPTHFILTERMODE"  "0..2"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"

// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)
// We don't care about flashlight depth unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTSHADOWS == 1 )
// Flashlight shadow filter mode is irrelevant if there is no flashlight
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTDEPTHFILTERMODE != 0 )

#include "common_ps_fxc.h"
#include "common_flashlight_fxc.h"
#include "shader_constant_register_map.h"

// Need an include for VLG Shader Functions
#include "common_vertexlitgeneric_dx9.h"

// WRD : I put some comments here. They are the USED registers!!!
// What does that mean? It means you owe me a beer

//  01 - Linear Color Space related
const float4 g_DiffuseModulation                : register(PSREG_DIFFUSE_MODULATION);
//  02
const float4 g_ShadowTweaks                     : register(PSREG_ENVMAP_TINT__SHADOW_TWEAKS);
//  11 - Eyeposition, usually has EnvMapLod in Alpha but no need here
const float4 g_EyePos                           : register(PSREG_EYEPOS_SPEC_EXPONENT);
//  12 - Fog stuff
const float4 g_FogParams                        : register(PSREG_FOG_PARAMS);
//  13 - Flashlight
const float4 g_FlashlightAttenuationFactors     : register(PSREG_FLASHLIGHT_ATTENUATION);
//  14 - Flashlight
const float4 g_FlashlightPos                    : register(PSREG_FLASHLIGHT_POSITION_RIM_BOOST);
//  15-18 - Flashlight
const float4x4 g_FlashlightWorldToTexture       : register(PSREG_FLASHLIGHT_TO_WORLD_TEXTURE);
//  20-25 - Used for Light Information
PixelShaderLightInfo cLightInfo[3]              : register(PSREG_LIGHT_INFO_ARRAY);         // 2 registers each - 6 registers total (4th light spread across w's)

// 27, shouldn't be used by anythin'
const float4 g_AtmosphereControl				: register(c27);
#define g_GradientPower (g_AtmosphereControl.w)
#define g_TransparencyFactor (g_AtmosphereControl.x)

const float4 g_NewEyePos						: register(c5);

 // PSREG Total
 // c0, c1 ,c2 ,c4, c5, c6, c7, c8, c9, c11, c12, c13, c14, c15 ,c16 ,c17 ,c18 ,c20 ,c21 ,c22 ,c23 ,c24 ,c25
 // PSREG Used by Flashlight
 // c2, c13, c14, c15, c16, c17, c18 ,c28, ( technically c31 aswell )

sampler BaseTextureSampler          : register(s0);     // BaseTexture
sampler ShadowDepthSampler          : register(s4);     // Flashlight shadow depth map sampler
sampler RandRotSampler              : register(s5);     // RandomRotation sampler
sampler FlashlightSampler           : register(s6);     // Flashlight cookie 

// Here we get anything that the VertexShader can spit us out
struct PS_INPUT
{
    float2 baseTexCoord             : TEXCOORD0;
    float4 lightAtten               : TEXCOORD1;
//	worldspacenormal, no normal map. Just things like smoothing etc
    float3 worldNormal              : TEXCOORD2;
    float3 worldPos                 : TEXCOORD3;
    float3 projPos                  : TEXCOORD4;
	// can't remove these just yet.
    float4 lightmapTexCoord1And2    : TEXCOORD5; 
    float4 lightmapTexCoord3        : TEXCOORD6;

	float4 StaticVertexLighting		: TEXCOORD7;		// Vertex color (from lighting or unlit)
};
  
// Entry point
float4 main(PS_INPUT i) : COLOR
{
// Corrected BaseTexCoords
    float2 correctedTexCoord = i.baseTexCoord;

// BaseTexture float
    float4 BaseTexture = tex2D(BaseTextureSampler, correctedTexCoord);
	// Apply linear colorspace if any
    BaseTexture.xyz *= g_DiffuseModulation;

	// great we have the basetexture now. That took a while



// IMPORTANT, no flashlight

float3 diffuseLighting = 1.0f;

// only WITH flashlight - Basically stock VLG code
    // Start flashlight
    if (FLASHLIGHT)
    {
		// Just like in stock vlg Except we Clip the result
        float4 flashlightSpacePosition = mul(float4(i.worldPos, 1.0), g_FlashlightWorldToTexture);
        clip( flashlightSpacePosition.w ); // stop projected textures from projecting backwards (only really happens if they have a big FOV because they get frustum culled.)

		// We do diffuse only version
		// if error from FLASHLIGHTDEPTHFILTERMODE use this
		//int nShadowSampleLevel = 0;
		//nShadowSampleLevel = FLASHLIGHTDEPTHFILTERMODE;
		// magical code ( Look in common_flashlight_fxc.h for actual function )
		float3 FlashlightFinal = DoFlashlight( g_FlashlightPos, i.worldPos.xyz, flashlightSpacePosition,
			i.worldNormal.xyz, g_FlashlightAttenuationFactors.xyz, 
			g_FlashlightAttenuationFactors.w, FlashlightSampler, ShadowDepthSampler,
			RandRotSampler, FLASHLIGHTDEPTHFILTERMODE, true, false, i.projPos.xy / i.projPos.z, false, g_ShadowTweaks, true );
			// the second last bool is probably worthless, its not even mentioned. In either case we clip it before so setting it to false is probably correct

		// Other lighting is disabled with Flashlight on, therefore just overwriting is faster and better than doing +=
		diffuseLighting += FlashlightFinal;
    }
    // End flashlight

// CalcPixelFogFactor is a function from common_ps_fxc.h Which is included at the beginning of the shader
    float fogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, i.worldPos.xyz, i.projPos.z);
#if !FLASHLIGHT

#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    float alpha = fogFactor;
#else
    float alpha = BaseTexture.a;
#endif // WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)

#else
    float alpha = 0.0f;
#endif // !FLASHLIGHT

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);


	// add the lighting we computed onto the actual color of our model
	float3	diffuseComponent = BaseTexture.xyz;
	diffuseComponent *= diffuseLighting;

	// we make a vector from eyepos and worldpos, normalize it and make the dot product from the vector and the worldnormal
	float gradient = saturate(dot(i.worldNormal.xyz, normalize(g_NewEyePos.xyz - i.worldPos.xyz)));

	gradient = pow(gradient, g_GradientPower);

	diffuseComponent *= gradient;

	alpha *= gradient * g_TransparencyFactor;
	alpha *= g_DiffuseModulation.a;

	diffuseComponent = diffuseComponent - (i.StaticVertexLighting.xyz * g_TransparencyFactor);

    return FinalOutput(float4(diffuseComponent, alpha), fogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, i.projPos.z);
}